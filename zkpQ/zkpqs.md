## zkp

### 理论方面

1. 在区块链应用中，ZKP 可以有效保护用户隐私。请详细阐述一下在隐私保护方面，ZKP 是如何具体应用于区块链交易场景的？比如在隐藏交易金额、交易双方身份等关键信息上，它的实现原理和流程是怎样的？
2. 目前有多种 ZKP 方案，如 ZK - SNARK 和 ZK - STARK 等，在区块链公链底层开发中，如果要选择其中一种来实现某个涉及隐私计算的功能，你会从哪些方面去考虑它们的优劣并做出选择呢？请结合具体的功能需求（比如计算复杂度、验证效率、可扩展性等方面）进行分析。
3. 零知识证明（ZKP）在区块链的智能合约领域也有不少应用。假设我们要开发一个智能合约，需要在不泄露敏感数据的情况下验证某些条件是否满足（比如验证用户是否有足够的余额进行某项交易，但不暴露具体余额）。请说明如何运用 ZKP 技术来实现这个智能合约功能，并且从代码实现和合约部署的角度谈谈可能会遇到哪些挑战以及如何应对？
4. 在区块链的跨链交互场景中，ZKP 是否能起到作用呢？如果能，请举例说明一个具体的跨链交互场景，并详细解释在这个场景中 ZKP 是如何实现信息的隐私保护和验证的，包括相关的流程和涉及的技术要点。
5. 随着区块链技术的不断发展，对 ZKP 的性能要求也越来越高。从技术层面来说，目前有哪些方法可以提升 ZKP 在区块链应用中的性能呢？比如在减少证明生成时间、优化验证过程等方面，你可以结合自己的经验或者了解到的最新研究成果来谈谈哦。
6. 在区块链公链底层实现 ZKP 时，数据的存储和管理是一个重要问题。因为 ZKP 涉及到大量的计算和复杂的数据结构（如多项式约束系统等）。请谈谈你在这方面的经验或者思考，比如如何高效存储相关数据，如何确保数据在不同节点间的一致性和完整性等。
7. 安全性是区块链的重中之重，虽然 ZKP 本身具有一定的安全性优势，但在实际应用中也可能存在一些安全隐患。请分析一下在区块链场景下，ZKP 可能存在哪些安全风险，以及针对这些风险，有哪些防范措施可以采取？
8. ZK-DSL 都有哪些呢？
9. 什么是零知识证明的完备性和零知识性？如何形式化定义这些性质？
10. 描述 Merkle 树的结构及其在区块链和 ZKP 中的应用

### 实战

1. 在高性能计算场景下（如 ZKP proof 生成），Rust 和 C++ 的性能对比如何？

2. 如何在 Rust 中优化内存管理以提高 ZKP 证明生成的效率？

   1. 可以从生命周期、内存管理入手

3. zk-SNARK 和 zk-STARK 的核心区别是什么？各自的优缺点如何？

   1. 轨迹多项式，消失多项式、商多项式，R1CS 等各个角度入手
   2. proof size 倒是其次
   3. trust setup 这个是必须要说的

4. 如何实现 Groth16 或 Plonk 的电路优化？

   1. Groth16 优化：
      1. 约束优化：约束合并，约束重用、约束简化
      2. 多项式优化：多项式分解（高阶多项式分解为低阶多项式，减少计算消耗）
      3. Pairing 操作优化：Pairing 友好曲线选择、**Pairing 操作并行化：** 利用多核处理器或 GPU 并行执行 pairing 操作。
      4. 电路结构优化：查表优化：将频繁使用的子电路替换为查找表，减少计算量。 **电路重构：** 通过改变电路结构，减少约束数量和电路深度。
   2. plonk 优化：
      1. 门类型优化：
      2. 多项式承诺方案优化：
         1. **KZG 承诺优化：** 优化 KZG 承诺的生成和验证算法
         2. **FRI 承诺优化：** 优化 FRI 承诺的交互轮数和证明大小。
      3. Permutation 优化：
         1. **Permutation 检查优化：** 优化 permutation 检查的算法
      4. 电路结构优化
         1. **电路并行化：** 将电路划分为多个并行执行的部分。
         2. 查表优化。

5. 什么是多项式承诺？在 Plonk 中它是如何使用的？

   1. prover向verifier 承诺一个多项式，而无需透露多项式的具体系数。证明者可以稍后“打开”承诺，证明在某个特定点上多项式的值。

   2. plonk 中的使用：

      1. **约束满足性证明：** 证明者需要证明所有多项式都满足电路中的约束条件。

         **排列检查：** Plonk 使用排列检查来确保电路中的线按照正确的顺序连接。多项式承诺被用来证明排列的正确性。

         **多项式等式证明：** 证明者需要证明两个多项式相等。

6. 在 zkEVM 中，如何处理电路的逻辑与 EVM 操作码的映射问题？

   1. 逐条映射：逐个实现evm的opcode，每个opcode都有独立的电路模块
   2. 中间表示：将 EVM 字节码转换为一个更适合电路表达的中间形式，然后再将中间形式映射到电路。

7. 递归证明的原理是什么？在 zkEVM 中递归证明的应用场景有哪些？

   1. 每个单独的计算都会生成一个基底证明，将多个基底证明作为输入，生成一个新的证明，这个新的证明证明了所有输入证明的正确性。通过不断地递归，可以构建一个证明树，树的叶子节点是基底证明，根节点是最终的递归证明。

   2. 技术细节：

      1. **电路嵌入：** 将一个证明的验证电路嵌入到下一个证明的计算电路中。

         **参数传递：** 将上一层证明的输出作为下一层证明的输入。

         **安全性：** 递归证明的安全性依赖于底层证明系统的安全性。

8. 请描述你在 GPU 加速 zk-SNARK/zk-STARK 证明生成中的实践经验。

9. 可验证增量计算的原理

   1. 允许在不重新计算整个任务的前提下，验证增量更新的正确性。即在已有的计算结果基础上，只对修改/新增的数据进行计算，并生成证明。

   

10. 在 CUDA 或 OpenCL 中，如何最大化利用硬件并行能力？

11. zk-SNARK 的 Halo2 和 Plonky2 有什么主要区别？

    1. 数学基础

       1. Halo2 ： plonk + KZG + 查找表
       2. Plonky2: plonk + FRI 

    2. 电路设计

       1. Halo2 提供可电路定制机制，允许开发者定义自定义门和查表逻辑。针对递归证明进行了高度优化，证明生成依赖高效的门结构和约束。
       2. Plonky2 借鉴了 STARK 的 AIR（算术中间表示）思想，将约束表示为多项式轨迹。更适合并行化计算，充分利用 GPU 加速证明生成。

    3. 可信设置

       1. Halo2 使用 **KZG 承诺**，需要一次性可信设置
       2. Plonky2 使用 **FRI**，完全去除了可信设置的需求。

    4. 性能

       1. Halo2:
          1. 证明较小，适合递归应用
          2. 证明生成速度中等，相较于 Plonky2 较慢。
          3. 验证过程较快，适用于对验证时间要求高的应用。
       2. Plonky2:
          1. 证明较大，偏向高扩展性场景。
          2. 证明生成速度极快，适合高吞吐量系统
          3. 验证时间相对 Halo2 稍长，但仍在可接受范围内

       

12. FRI 协议的核心思想是什么？如何提高它的效率？

    1. FRI 核心思想 通过 **抽样、多项式折叠和递归降阶**，用较小的计算和通信成本验证一个多项式的低阶性
    2. 优化：
       1. 优化多项式折叠
          1. FFT 优化： 使用快速傅里叶变换（FFT）提高多项式评估效率，减少对域上点的直接计算。
          2. 并行优化计算：将多项式评估和折叠过程并行化，利用多核 CPU 或 GPU 提升速度。
       2. 减少交互轮次
          1. 将多轮挑战合并成一轮，减少交互次数。
          2. 预计算一些中间结果，减少在线计算量。
       3. 优化merkle tree 操作
          1. 对多个抽样点的 Merkle 路径进行批量验证，减少重复计算。
          2. 使用GPU加速 
       4. 递归验证
          1. 在降阶过程中引入递归验证，将多个折叠证明合并成一个更小的递归证明，进一步压缩证明大小





